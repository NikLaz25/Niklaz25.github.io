---
layout: post
title:  "Множества (изучаю структуры данных)"
date:   2022-02-25 00:00:00 +0000
categories: python algorithms
---
[id_1]: https://github.com/NikLaz25/Algorithms_1/blob/main/PowerSet_5.py
[id_2]: https://github.com/NikLaz25/Algorithms_1/blob/main/PowerSet_test_5.py

Осваиваю структуру данных Множество.
Из всех освоенных ранее структур данных эта оказалась для меня наиболее сложной. В ней оказалось пару фишек по ООП, которые я узнал. Чуть ниже опишу их.

Итак, имеем неупорядоченное хранилище с уникальными значениями.

Особое требование по быстродействию, программа должна обрабатывать десятки тысяч значений за пару секунд. Поэтому сложность проверки принадлежности к множеству должна быть О(1).

Особая фишка! Один класс должен работать с одним типом данных. 

Для реализации был выбран вариант словаря т.к. он добавляет в качестве ключа только уникальные значения.
По условию использовать set было нельзя.

Реализованы следующие методы:

*    def__init__(self):
	'''Конструктор'''


*    def find(self, value):
        '''проверяет, имеется ли в слотах указанное значение,
        и возвращает либо слот, либо None'''


*    def size(self):
        '''количество элементов в множестве'''

*   def put(self, value):
        '''помещает значение value в слот'''

*    def get(self, value):
        '''возвращает True если value имеется в множестве, иначе False'''

*    def remove(self, value):
        '''возвращает True если value удалено иначе False'''

*    def intersection(self, set2):
        '''пересечение текущего множества и set2'''

*    def union(self, set2):
        '''объединение текущего множества и set2'''

*    def difference(self, set2):
        '''разница текущего множества и set2, то что не входит в set2'''

*    def issubset(self, set2):
        '''возвращает True, если set2 есть подмножество
        текущего множества, иначе False'''

Так вот, фишка в том, что при реализации основных методов ( intersection, union, difference, issubset) для множества необходимо было создать экземпляр основного класса в самом методе. А также в качестве set2 должен был поступать на вход ещё один экземпляр. Т.е. и на входе и на выходе один тип данных - PowerSet.
 Если бы я сразу сделал аннотацию типов, то быстрее бы понял эту особую фишку.


[Ссылка на мой код] [id_1]
Код многократно проверен на линтере.

[Ссылка на тесты] [id_2]




