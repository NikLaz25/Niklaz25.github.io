---
layout: post
title:  "Двойная очередь (изучаю структуры данных)"
date:   2022-02-06 00:00:00 +0000
categories: python algorithms
---
[id_1]: https://github.com/NikLaz25/Algorithms_1/blob/main/queue_2.py
[id_2]: https://github.com/NikLaz25/Algorithms_1/blob/main/queue_2_test.py
[id_3]: https://github.com/NikLaz25/Algorithms_1/blob/main/queue_LinkedList.py




Осваиваю двойную очередь на основе стандартного списка.
Проработаны следующие методы:

* def __init__(self): '''инициализация внутреннего хранилища'''

* def addFront(self, item): # мера сложности О(N)
        '''добавление в голову'''

* def addTail(self, item): # мера сложности О(1)
        '''добавление в хвост'''

* def removeFront(self): # мера сложности О(N)
        '''удаление из головы'''

* def removeTail(self): # мера сложности О(1)
        '''удаление из хвоста'''

* def size(self):
        '''размер очереди'''

* def print_list(self):
        '''Печать списка'''

Также проработан метод  def check_polinom(polinom):
    '''функция, которая с помощью deque проверяет,
    является ли некоторая строка палиндромом
    (читается одинаково слева направо и справа налево)'''.

[Ссылка на мой код] [id_1]

Код проверен с помощью линтера pylint, оценена мера сложности.
Можно отметить,  что методы работы с головой и хвостом очереди отличаются по мере сложности. 
Разобрался в причине этого отличия :)

[Ссылка на код теста] [id_2]

Также проработан вариант двойной очереди на основе двунаправленного связанного списка. 
Методы аналогичные. 

[Ссылка на код] [id_3]



